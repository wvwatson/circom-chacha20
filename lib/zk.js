"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyProof = exports.generateProof = exports.IV_SIZE_BYTES = exports.KEY_SIZE_BYTES = exports.ZK_CIRCUIT_CHUNK_SIZE = void 0;
const utils_1 = require("./utils");
// chunk size of data that is input to the ZK circuit
// in 32-bit words
exports.ZK_CIRCUIT_CHUNK_SIZE = 16;
// key size in bytes
exports.KEY_SIZE_BYTES = 32;
// iv size in bytes
exports.IV_SIZE_BYTES = 12;
/**
 * Generate ZK proof for CHACHA20-CTR encryption.
 * Circuit proves that the ciphertext is a
 * valid encryption of the given plaintext.
 * The plaintext can be partially redacted.
 *
 * @param privateInput private input to the circuit
 * will include the key, iv, and counter
 * @param pub public input to the circuit,
 * will include the ciphertext and redacted plaintext
 * @param zkParams ZK params -- verification key and circuit wasm
 */
async function generateProof({ key, iv, startCounter, }, { ciphertext }, operator) {
    if (key.length !== exports.KEY_SIZE_BYTES) {
        throw new Error(`key must be ${exports.KEY_SIZE_BYTES} bytes`);
    }
    if (iv.length !== exports.IV_SIZE_BYTES) {
        throw new Error(`iv must be ${exports.IV_SIZE_BYTES} bytes`);
    }
    const ciphertextArray = normaliseCiphertextForZk(ciphertext);
    const keyU32 = (0, utils_1.toUintArray)(key);
    const nonce = (0, utils_1.toUintArray)(iv);
    const { proof, publicSignals } = await operator.groth16FullProve({
        key: Array.from(keyU32),
        nonce: Array.from(nonce),
        counter: startCounter,
        in: Array.from(ciphertextArray),
    });
    return {
        proofJson: JSON.stringify(proof),
        plaintext: (0, utils_1.makeUintArray)(publicSignals
            .slice(0, exports.ZK_CIRCUIT_CHUNK_SIZE)
            .map((x) => +x))
    };
}
exports.generateProof = generateProof;
/**
 * Verify a ZK proof for CHACHA20-CTR encryption.
 *
 * @param proofs JSON proof generated by "generateProof"
 * @param publicInput
 * @param zkey
 */
async function verifyProof({ proofJson, plaintext }, { ciphertext }, operator) {
    const ciphertextArray = normaliseCiphertextForZk(ciphertext);
    if (ciphertextArray.length !== plaintext.length) {
        throw new Error(`ciphertext and plaintext must be the same length`);
    }
    // serialise to array of numbers for the ZK circuit
    const pubInputs = getSerialisedPublicInputs({
        ciphertext: ciphertextArray,
        decryptedRedactedCiphertext: plaintext
    });
    const verified = await operator.groth16Verify(pubInputs, JSON.parse(proofJson));
    if (!verified) {
        throw new Error('invalid proof');
    }
}
exports.verifyProof = verifyProof;
/**
 * Serialise public inputs to array of numbers for the ZK circuit
 * the format is spread (output, ciphertext, redactedPlaintext)
 * @param inp
 */
function getSerialisedPublicInputs({ decryptedRedactedCiphertext, ciphertext }) {
    return [
        ...Array.from(decryptedRedactedCiphertext),
        ...Array.from(ciphertext),
    ];
}
function normaliseCiphertextForZk(ciphertext) {
    const ciphertextArray = (0, utils_1.padArray)((0, utils_1.toUintArray)((0, utils_1.padU8ToU32Array)(ciphertext)), exports.ZK_CIRCUIT_CHUNK_SIZE);
    if (ciphertextArray.length !== exports.ZK_CIRCUIT_CHUNK_SIZE) {
        throw new Error(`ciphertext must be ${exports.ZK_CIRCUIT_CHUNK_SIZE} words`);
    }
    return ciphertextArray;
}
